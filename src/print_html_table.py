
from __future__ import annotations
import argparse
from collections import defaultdict
from dataclasses import dataclass
import json
from typing import Dict, List
import pickle
import pandas as pd
import regex
import multiprocessing
import numpy as np
from types import SimpleNamespace
from curriculums import curriculums
import util
import re

COURSE_CODE_REGEX = re.compile(r"\[([A-Z0-9]+)\]")
COURSE_CODE_PARENTHESIS_REGEX = re.compile(r" (\([A-Z0-9]+\)|\[[A-Z0-9]+\])$")

THEORY_NODE_NAMES = ["Theorie", "Theory"]

# REGISTRATION_BASE_URL = "https://campus.tum.de/tumonline/ee/rest/pages/slc.tm.cp/course-registration/" 
COURSE_DETAILS_BASE_URL = "https://campus.tum.de/tumonline/ee/ui/ca2/app/desktop/#/slc.tm.cp/student/courses/"

STYLE = """
<style>
    .main-container {
        width: 95%;
        display: inline-grid;
        justify-items: center;
        font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";
    }
    @media (min-width: 1150px) {
        .main-container {
            width: 50%;
        }
    }
    table {
        table-layout: fixed;
        width: 100%;
        word-wrap: break-word;
        border: 0px;
        font-family: "Arial";
        font-size: 0.92rem;
        line-height: 1.3rem;
    }
    td, th {
        border: 0px;
    }
    td {
      padding-top: 0.7rem;
      padding-bottom: 0.7rem;
    }
    th {
        text-align: left;
    }
    .titleheader {
        width: 60%;
    }
    body {
        width: 100%;
        margin: 0px;
        display: inline-grid;
        justify-items: center;
        font-size: 1rem;
        margin-bottom: 3.4rem;
    }
    tbody tr:nth-child(odd) {
      background-color: #f6f6f6;
    }
    @media (min-resolution: 150dpi) {
      body {
        font-size: 1.7rem;
      }
      table {
        font-size: calc(1.9*0.92rem);
        line-height: calc(1.9*1.3rem);
      }
      .titleheader {
          width: 40%;
      }
    }
    @media (min-resolution: 300dpi) {
      body {
        font-size: 2rem;
      }
      table {
        font-size: calc(2.1*0.92rem);
        line-height: calc(2.1*1.3rem);
      }
      .titleheader {
          width: 40%;
      }
    }
    .tagIcon {
      cursor: default
    }
</style>
"""

RARE_NEW_COURSES_EXPLANATION = """
<p>
ðŸ’Ž: Rare course (not offered in the last two semesters) <br>
ðŸŒŸ: New course (offered for the first time)
</p>
"""

construct_header = lambda with_rare_and_new_courses: f"""
<div style="text-align: justify;">
<p>
    This is a list of elective modules grouped by area with availability data, which as far as I know is not provided by TUM elsewhere in a convenient format. I hope it will be helpful to you!
</p>
{RARE_NEW_COURSES_EXPLANATION if with_rare_and_new_courses else ""}

<p>
    <b>Disclaimer:</b> This site is non-official and automatically generated by fetching the data from the curriculum tree view and the data from the Courses tab in TUM online, and merging
    it based on course page URL. It can contain errors, or courses can be missing, for example if there is a bug in my code (has happened before), or if a new course was not yet present in the tree view at the time this list was created. Use with care (and please notify me if you find any errors).</li>
</ul>
</div>
"""

HEADER_SINGLE_TERM = construct_header(with_rare_and_new_courses=True)
HEADER_ALL_TERMS = construct_header(with_rare_and_new_courses=False)


GITHUB_LINK_AND_KOFI_BUTTON = """
<div style="width: 100%; margin-top: 10px; display: flex; align-items: center">
    <div style="display: flex; align-items: center; margin-right: 20px; padding-top: 3px;">
        <img src="github-mark.svg" style="height: 22px; aspect-ratio: 1/1; margin-right: 5px; padding-bottom: 4px">
        <a href="https://github.com/Vuenc/TUM-Master-Informatics-Offered-Lectures">
            This project on Github
        </a>
    </div>
    <script type='text/javascript' src='https://storage.ko-fi.com/cdn/widget/Widget_2.js'></script>
    <script type='text/javascript'>kofiwidget2.init('Buy me a Coffee', '#29abe0', 'K3K6135GAH');kofiwidget2.draw();</script> 
</div>
"""

NEW_COURSE_TAG_HTML_FACTORY = lambda _: """<span title="New course: offered for the first time!" class="tagIcon">ðŸŒŸ</span>"""

RARE_COURSE_TAG_HTML_FACTORY = lambda tag_and_last_offered: f"""<span title="Rare course: last offered in {tag_and_last_offered['last_offered']}" class="tagIcon">ðŸ’Ž</span>"""


TAG_FACTORIES = {
    "newCourse": NEW_COURSE_TAG_HTML_FACTORY,
    "rareCourse": RARE_COURSE_TAG_HTML_FACTORY,
}

@dataclass
class Course:
    title: str
    url: str
    course_code: str
    term_id: int
    term_name: str
    credits: str
    equivalent_courses: List[Course]
    curriculum_path: List[str]

def main():
    parser = argparse.ArgumentParser(usage=
    """
    print_html_table.py [-h] --termid TERMID --curriculum CURRICULUM --output PATH [--oldtermsfrom OLDTERMID]
    Please provide the term id: winter 2022/23 is 197, summer 2023 is 198, winter 2023/24 is 199, etc.
    Curriculum: valid options are `master-informatics', 'master-dea'
    """)
    parser.add_argument('--termid', required=True, type=int, help="The term id (winter 2022/23 is 197, summer 2023 is 198, etc.)")
    parser.add_argument("--curriculum", required=True, type=str, help="One of ['master-informatics', 'master-dea']")
    parser.add_argument("--output", required=True, type=str, help="Path where to write the output html")
    parser.add_argument("--oldtermsfrom", required=False, type=int, help="The term id starting at which old course availability data (last offered) should be fetched")
    args = parser.parse_args()

    curriculum = curriculums[args.curriculum]

    with open(curriculum.all_offered_courses_path) as f:
        available_data = json.load(f)
        available_courses_dtos = available_data["courses"]
    with open(curriculum.tree_file_path) as f:
        curriculum_course_infos = json.load(f)
    curriculum_courses_by_url = {url[url.rfind("/"):]: course_info for course_info in curriculum_course_infos for url in course_info["urls"]}

    available_courses_dtos = sorted(available_courses_dtos, key=lambda course_dto: int(course_dto["semesterDto"]["id"]), reverse=True)
    courses_by_area = defaultdict(lambda: [])
    equivalent_courses_by_oldest_related_course_id = {}
    for course_dto in available_courses_dtos:
        is_in_term_range = int(course_dto["semesterDto"]["id"]) >= (args.oldtermsfrom or args.termid)
        url = f"{COURSE_DETAILS_BASE_URL}{course_dto["id"]}"
        equivalent_courses = equivalent_courses_by_oldest_related_course_id.get(int(course_dto["oldestRelatedCourseId"]), None)
        if equivalent_courses == []:
            continue
        
        area = None
        course_code = None
        credits = None
        curriculum_path = None
        if equivalent_courses is None:
            # This is the youngest of its equivalence class, and we should extract the area
            curriculum_course_info = curriculum_courses_by_url.get(url[url.rfind("/"):])
            if curriculum_course_info is None:
                print(f"Course {course_dto["title"]} ({util.term_id_to_name(course_dto["semesterDto"]["id"])}) belonging to URL {url} not found in curriculum!")
                equivalent_courses_by_oldest_related_course_id[int(course_dto["oldestRelatedCourseId"])] = []
                continue
            assert curriculum_course_info is not None
            curriculum_path = list(curriculum_course_info["rule_node_names_by_levels"].values())
            area = curriculum.extract_area(curriculum_path)
            if area is None:
                equivalent_courses_by_oldest_related_course_id[int(course_dto["oldestRelatedCourseId"])] = []
                continue
            course_code_match = COURSE_CODE_REGEX.match(curriculum_course_info["module_name"]) if curriculum_course_info is not None else None
            course_code = course_code_match.groups()[0] if course_code_match is not None else "?"
            credits = str(curriculum_course_info["num_credits"]) if curriculum_course_info is not None else "?"
        else:
            course_code = equivalent_courses[0].course_code
            credits = equivalent_courses[0].credits
            curriculum_path = equivalent_courses[0].curriculum_path
        course = Course(
            title=COURSE_CODE_PARENTHESIS_REGEX.sub("", course_dto["title"]),
            url=url,
            course_code=course_code,
            credits=credits,
            term_id = course_dto["semesterDto"]["id"],
            term_name=util.term_id_to_name(course_dto["semesterDto"]["id"]),
            equivalent_courses=[], # will be set later
            curriculum_path=curriculum_path,
        )
        if equivalent_courses is None:
            equivalent_courses = [course]
            equivalent_courses_by_oldest_related_course_id[int(course_dto["oldestRelatedCourseId"])] = equivalent_courses
            if is_in_term_range:
                courses_by_area[area].append(course)
        else:
            equivalent_courses.append(course)

        course.equivalent_courses = equivalent_courses

    terms = [(term_id, util.term_id_to_name(term_id)) for term_id in range(args.oldtermsfrom if args.oldtermsfrom is not None else args.termid, args.termid+1) if term_id not in [201, 202]]
    terms_dict = {term_name: term_id for term_id, term_name in terms}
    terms_dict["?"] = 0 # sort "unknown" last
    include_last_offered = args.oldtermsfrom is not None
    title = f"{curriculum.heading} - offered in {terms[-1][1]}{(' and in previous semesters') if include_last_offered else ''}"

    print(f"""\nCreating table "{title}"...""")


    curriculum_entry_paths = [list(curriculum_course_info["rule_node_names_by_levels"].values()) for curriculum_course_info in curriculum_course_infos]
    areas_according_to_curriculum_tree = list({area: 0 for path in curriculum_entry_paths if (area := curriculum.extract_area(path)) is not None})
    print("Areas:", areas_according_to_curriculum_tree)

    with open(args.output, "w") as file:
        file.write("<!DOCTYPE html><html lang='en'><body>")
        file.write("<div class=\"main-container\">")
        file.write(f"<h1>{title}</h1>")
        file.write(HEADER_SINGLE_TERM if args.oldtermsfrom is None else HEADER_ALL_TERMS)
        file.write(GITHUB_LINK_AND_KOFI_BUTTON)

        for area, courses_in_area in sorted(courses_by_area.items(), key=lambda area_and_val: areas_according_to_curriculum_tree.index(area_and_val[0])):
            file.write(f"<h3>{area}</h3>\n")
            file.write("<table>\n")
            file.write(
f"""<thead>
<tr style="text-align: right;">
    <th>ID</th>
    <th class="titleheader">Title</th>
    <th>Credits</th>
    {"\n".join([f"<th>{key}</th>" for key in curriculum.extra_columns.keys()])}
    {'<th>Last offered</th>' if include_last_offered else ''}
</tr>
</thead>""")
            file.write("<tbody>\n")
            for course in sorted(courses_in_area, key=lambda course: (-course.term_id, course.title)):
                tags = []
                equivalent_courses = course.equivalent_courses
                if args.oldtermsfrom is None:
                    if len(equivalent_courses) == 1:
                        tags.append(dict(tag="newCourse"))
                    if (len(equivalent_courses) > 1 and equivalent_courses[0].term_id == args.termid
                            and util.term_id_distance(equivalent_courses[0].term_id, equivalent_courses[1].term_id) > 2):
                        tags.append(dict(tag="rareCourse", last_offered=util.term_id_to_name(equivalent_courses[1].term_id)))
                tags_html = " ".join(TAG_FACTORIES[tag["tag"]](tag) for tag in tags)

                file.write(
f"""<tr>
    <td>{course.course_code} {tags_html}</td>
    <td><a href="{course.url}">{course.title}</a></td>
    <td>{course.credits}</td>
    {"\n".join([f"<td>{value_extractor(course)}</td>" for value_extractor in curriculum.extra_columns.values()])}
    {f'<td>{course.term_name}</td>' if include_last_offered else ''}
</tr>"""
            )
            file.write("</tbody></table>\n")

        file.write("</div>")
        file.write("</body>")
        file.write(STYLE)
        file.write("</html>")
    print("Wrote table to file", args.output)

if __name__ == "__main__":
    main()
