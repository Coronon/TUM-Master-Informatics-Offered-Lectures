import argparse
from typing import Dict, List
import fetch_courses
import pickle
import pandas as pd
import regex
import multiprocessing
import numpy as np
from types import SimpleNamespace
from curriculums import curriculums

COURSE_CODE_REGEX = regex.compile("\\[([A-Z]+\\d+)\\]")

THEORY_NODE_NAMES = ["Theorie", "Theory"]

# Informatics
# USE_THEORY, TREE_FILE = True, "tumonline_tree_informatics.obj"
# # DEA
# USE_THEORY, TREE_FILE = False, "tumonline_tree_dea.obj"

# INCLUDE_LAST_OFFERED = False

# REGISTRATION_BASE_URL = "https://campus.tum.de/tumonline/ee/rest/pages/slc.tm.cp/course-registration/" 
COURSE_DETAILS_BASE_URL = "https://campus.tum.de/tumonline/ee/ui/ca2/app/desktop/#/slc.tm.cp/student/courses/"

STYLE = """
<style>
    .main-container {
        width: 95%;
        display: inline-grid;
        justify-items: center;
        font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";
    }
    @media (min-width: 1150px) {
        .main-container {
            width: 50%;
        }
    }
    table {
        table-layout: fixed;
        width: 100%;
        word-wrap: break-word;
        border: 0px;
        font-family: "Arial";
        font-size: 0.92rem;
        line-height: 1.3rem;
    }
    td, th {
        border: 0px;
    }
    th {
        text-align: left;
    }
    .titleheader {
        width: 60%;
    }
    body {
        display: inline-grid;
        justify-items: center;
    }
    tbody tr:nth-child(odd) {
      background-color: #f6f6f6;
    }
</style>
"""

DISCLAIMER = """
<h2>Disclaimer</h2>
<div style="text-align: justify;">
<p>
    This is a list of elective modules grouped by area with availability data, which as far as I know is not provided by TUM elsewhere. I hope it will be helpful to you!
</p>
<p>
    This site is non-official and automatically generated by fetching the data from the curriculum tree view and the data from the Courses tab in TUM online, and merging
    it based on the course identifiers. It can contain errors, for example if
</p>
<ul>
  <li>a course is missing the course identifier (INxxxx etc.) from its name</li>
  <li>a course was still missing from the tree view at the time of creation</li>
</ul>
</div>
"""

GITHUB_LINK = """
<span style="width: 100%; margin-top: 10px;">
    <a href="https://github.com/Vuenc/TUM-Master-Informatics-Offered-Lectures" style="display: flex;">
       <img src="github-mark.svg" style="height: 22px; aspect-ratio: 1/1; margin-right: 10px;">
        This project on Github
    </a>
</span>
"""

def fetch_courses_for_term(term_id_name):
    term_id, term_name = term_id_name
    term_course_dtos = fetch_courses.fetch_course_dtos(term_id=term_id, only_master_informatics=      False    )
    for course_dto in term_course_dtos:
        course_dto["termName"] = term_name
        course_dto["title"] = next((t["value"] for t in course_dto["courseTitle"]["translations"]["translation"] if t["lang"] == "en" and "value" in t), course_dto["courseTitle"]["value"])
    return term_course_dtos

def term_id_to_name(term_id):
    assert(term_id >= 152 and term_id <= 350)
    return f"{'SS' if term_id % 2 == 0 else 'WS'}{str(23 + int((term_id - 198 - (term_id % 2))/2)).zfill(2)}{'/' + str(23 + int((term_id - 198 + 1)/2)).zfill(2) if term_id % 2 == 1 else ''}"

def main():
    parser = argparse.ArgumentParser(usage=
    """
    print_html_table.py [-h] --termid TERMID --curriculum CURRICULUM --output PATH [--oldtermsfrom OLDTERMID]
    Please provide the term id: winter 2022/23 is 197, summer 2023 is 198, winter 2023/24 is 199, etc.
    Curriculum: valid options are `master-informatics', 'master-dea'
    """)
    parser.add_argument('--termid', required=True, type=int, help="The term id (winter 2022/23 is 197, summer 2023 is 198, etc.)")
    parser.add_argument("--curriculum", required=True, type=str, help="One of ['master-informatics', 'master-dea']")
    parser.add_argument("--output", required=True, type=str, help="Path where to write the output html")
    parser.add_argument("--oldtermsfrom", required=False, type=int, help="The term id starting at which old course availability data (last offered) should be fetched")
    args = parser.parse_args()

    curriculum = curriculums[args.curriculum]
    terms = [(term_id, term_id_to_name(term_id)) for term_id in range(args.oldtermsfrom if args.oldtermsfrom is not None else args.termid, args.termid+1)]
    terms_dict = {term_name: term_id for term_id, term_name in terms}
    terms_dict["?"] = 0 # sort "unknown" last
    include_last_offered = args.oldtermsfrom is not None

    pool = multiprocessing.Pool(len(terms))
    available_courses_dtos = sum(pool.map(fetch_courses_for_term, reversed(terms)), [])

    with open(args.output, "w") as file:
        file.write("<!DOCTYPE html><html lang='en'><body>")
        file.write("<div class=\"main-container\">")
        file.write(f"<h1>{curriculum.heading} - offered in {terms[-1][1]}{(' and since ' + terms[0][1]) if include_last_offered else ''}</h1>")
        file.write(DISCLAIMER)
        file.write(GITHUB_LINK)
        with open(curriculum.tree_file, "rb") as f: tree = pickle.load(f)
        for electives_area_node in tree["children"]:
            file.write(f"<h3>{electives_area_node['name']}</h3>")
            course_row_dicts = compute_course_row_dicts_recursively(electives_area_node, available_courses_dtos, include_non_offered=include_last_offered)
            df = pd.DataFrame(data=course_row_dicts, columns=["ID", "Title", "Credits"]  + (["THEO"] if curriculum.use_theory_nodes else [])+ (["Last offered"] if include_last_offered else []))
            if include_last_offered:
                df = df.loc[np.argsort(-np.vectorize(lambda x: terms_dict[x])(df["Last offered"].to_numpy())), :]
            df["Title"] = df["Title"].apply(lambda title_url: f"<a href=\"{ title_url['url'] }\">{ title_url['title'] }</a>" if title_url['url'] is not None else title_url['title'])
            table_html = df.to_html(index=False, escape=False)
            table_html = table_html.replace("<th>Title</th>", "<th class='titleheader'>Title</th>")
            file.write(table_html)
        file.write("</div>")
        file.write("</body>")
        file.write(STYLE)
        file.write("</html>")

def compute_course_row_dicts_recursively(subtree: Dict, available_courses_dtos: List[Dict], include_non_offered: bool, is_theory_node=False) -> List[Dict]:
    course_row_dicts = []
    course_code_match = COURSE_CODE_REGEX.match(subtree["name"])
    if course_code_match is not None:
        course_code = course_code_match.groups()[0]
        available_course_dto = next(iter(sorted([dto for dto in available_courses_dtos if course_code in dto["title"]],
                key=lambda dto: (dto["termName"], 1 if dto["courseTypeDto"]["key"] in ["VO", "VI"] else 0),
                reverse=True)
            ), None)
        if available_course_dto is not None or include_non_offered:
            if available_course_dto is not None:
                base_title = available_course_dto["title"]
                register_url = f"{COURSE_DETAILS_BASE_URL}{available_course_dto['id']}"
                last_offered = available_course_dto["termName"]
            else:
                base_title = subtree["name"]
                register_url = None
                last_offered = "?"
            title = regex.sub(f"[\\(\\[]{regex.escape(course_code)}[\\)\\]]", "", base_title).strip()
            course_row_dicts.append({
                "Title": dict(title=title, url=register_url),
                "ID": course_code,
                "Credits": subtree["credits"],
                "Last offered": last_offered,
                "THEO": "THEO" if is_theory_node else "",
            })
    else:
        for child in subtree["children"]:
            course_row_dicts.extend(compute_course_row_dicts_recursively(child, available_courses_dtos, include_non_offered, is_theory_node or subtree["name"] in THEORY_NODE_NAMES))
    return course_row_dicts

if __name__ == "__main__":
    main()
