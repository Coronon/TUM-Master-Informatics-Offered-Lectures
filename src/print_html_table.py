
from __future__ import annotations
import argparse
from collections import defaultdict
from dataclasses import dataclass
import json
from typing import Dict, List
import pickle
import pandas as pd
import regex
import multiprocessing
import numpy as np
from types import SimpleNamespace
from curriculums import curriculums
import util
import re

COURSE_CODE_REGEX = regex.compile("\\[([A-Z]+\\d+)\\]")

THEORY_NODE_NAMES = ["Theorie", "Theory"]

# REGISTRATION_BASE_URL = "https://campus.tum.de/tumonline/ee/rest/pages/slc.tm.cp/course-registration/" 
COURSE_DETAILS_BASE_URL = "https://campus.tum.de/tumonline/ee/ui/ca2/app/desktop/#/slc.tm.cp/student/courses/"

STYLE = """
<style>
    .main-container {
        width: 95%;
        display: inline-grid;
        justify-items: center;
        font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";
    }
    @media (min-width: 1150px) {
        .main-container {
            width: 50%;
        }
    }
    table {
        table-layout: fixed;
        width: 100%;
        word-wrap: break-word;
        border: 0px;
        font-family: "Arial";
        font-size: 0.92rem;
        line-height: 1.3rem;
    }
    td, th {
        border: 0px;
    }
    td {
      padding-top: 0.7rem;
      padding-bottom: 0.7rem;
    }
    th {
        text-align: left;
    }
    .titleheader {
        width: 60%;
    }
    body {
        width: 100%;
        margin: 0px;
        display: inline-grid;
        justify-items: center;
        font-size: 1rem;
        margin-bottom: 3.4rem;
    }
    tbody tr:nth-child(odd) {
      background-color: #f6f6f6;
    }
    @media (min-resolution: 150dpi) {
      body {
        font-size: 1.7rem;
      }
      table {
        font-size: calc(1.9*0.92rem);
        line-height: calc(1.9*1.3rem);
      }
      .titleheader {
          width: 40%;
      }
    }
    @media (min-resolution: 300dpi) {
      body {
        font-size: 2rem;
      }
      table {
        font-size: calc(2.1*0.92rem);
        line-height: calc(2.1*1.3rem);
      }
      .titleheader {
          width: 40%;
      }
    }
    .tagIcon {
      cursor: default
    }
</style>
"""

RARE_NEW_COURSES_EXPLANATION = """
<p>
ðŸ’Ž: Rare course (not offered in the last two semesters) <br>
ðŸŒŸ: New course (offered for the first time)
</p>
"""

construct_header = lambda with_rare_and_new_courses: f"""
<div style="text-align: justify;">
<p>
    This is a list of elective modules grouped by area with availability data, which as far as I know is not provided by TUM elsewhere. I hope it will be helpful to you!
</p>
{RARE_NEW_COURSES_EXPLANATION if with_rare_and_new_courses else ""}

<p>
    <b>Disclaimer:</b> This site is non-official and automatically generated by fetching the data from the curriculum tree view and the data from the Courses tab in TUM online, and merging
    it based on the course identifiers. It can contain errors, for example if
</p>
<ul>
  <li>a course is missing the course identifier (INxxxx etc.) from its name</li>
  <li>a new course was not yet present in the tree view at the time this list was created</li>
</ul>
</div>
"""

HEADER_SINGLE_TERM = construct_header(with_rare_and_new_courses=True)
HEADER_ALL_TERMS = construct_header(with_rare_and_new_courses=False)


GITHUB_LINK_AND_KOFI_BUTTON = """
<div style="width: 100%; margin-top: 10px; display: flex; align-items: center">
    <div style="display: flex; align-items: center; margin-right: 20px; padding-top: 3px;">
        <img src="github-mark.svg" style="height: 22px; aspect-ratio: 1/1; margin-right: 5px; padding-bottom: 4px">
        <a href="https://github.com/Vuenc/TUM-Master-Informatics-Offered-Lectures">
            This project on Github
        </a>
    </div>
    <script type='text/javascript' src='https://storage.ko-fi.com/cdn/widget/Widget_2.js'></script>
    <script type='text/javascript'>kofiwidget2.init('Buy me a Coffee', '#29abe0', 'K3K6135GAH');kofiwidget2.draw();</script> 
</div>
"""

NEW_COURSE_TAG_HTML_FACTORY = lambda _: """<span title="New course: offered for the first time!" class="tagIcon">ðŸŒŸ</span>"""

RARE_COURSE_TAG_HTML_FACTORY = lambda tag_and_last_offered: f"""<span title="Rare course: last offered in {tag_and_last_offered['last_offered']}" class="tagIcon">ðŸ’Ž</span>"""


TAG_FACTORIES = {
    "newCourse": NEW_COURSE_TAG_HTML_FACTORY,
    "rareCourse": RARE_COURSE_TAG_HTML_FACTORY,
}

@dataclass
class Course:
    title: str
    url: str
    course_code: str
    term_id: int
    term_name: str
    credits: str
    is_theory_course: bool
    equivalent_courses: List[Course]

def main():
    parser = argparse.ArgumentParser(usage=
    """
    print_html_table.py [-h] --termid TERMID --curriculum CURRICULUM --output PATH [--oldtermsfrom OLDTERMID]
    Please provide the term id: winter 2022/23 is 197, summer 2023 is 198, winter 2023/24 is 199, etc.
    Curriculum: valid options are `master-informatics', 'master-dea', 'master-informatics-fspo2023'
    """)
    parser.add_argument('--termid', required=True, type=int, help="The term id (winter 2022/23 is 197, summer 2023 is 198, etc.)")
    parser.add_argument("--curriculum", required=True, type=str, help="One of ['master-informatics', 'master-dea']")
    parser.add_argument("--output", required=True, type=str, help="Path where to write the output html")
    parser.add_argument("--oldtermsfrom", required=False, type=int, help="The term id starting at which old course availability data (last offered) should be fetched")
    args = parser.parse_args()

    curriculum = curriculums[args.curriculum]

    with open(curriculum.all_offered_courses_path) as f:
        available_data = json.load(f)
        available_courses_dtos = available_data["courses"]
    with open(curriculum.tree_file_path) as f:
        curriculum_course_infos = json.load(f)
    curriculum_courses_by_url = {url[url.rfind("/"):]: course_info for course_info in curriculum_course_infos for url in course_info["urls"]}
    course_code_regex = re.compile(r"\[([a-zA-Z]+[0-9]+)\]")

    available_courses_dtos = sorted(available_courses_dtos, key=lambda course_dto: int(course_dto["semesterDto"]["id"]), reverse=True)
    courses_by_area = defaultdict(lambda: [])
    equivalent_courses_by_oldest_related_course_id = {}
    for course_dto in available_courses_dtos:
        # TODO support multiple paths
        # TODO support non-Informatics curriculums via custom code injection for this small part of the code (and everything below that contains "Elective Modules Informatics")
        is_in_term_range = int(course_dto["semesterDto"]["id"]) >= (args.oldtermsfrom or args.termid)
        url = f"{COURSE_DETAILS_BASE_URL}{course_dto["id"]}"
        equivalent_courses = equivalent_courses_by_oldest_related_course_id.get(int(course_dto["oldestRelatedCourseId"]), None)
        if equivalent_courses == []:
            continue
        
        area = None
        is_theory_course = None
        course_code = None
        credits = None
        if equivalent_courses is None:
            # This is the youngest of its equivalence class, and we should extract the area
            curriculum_course_info = curriculum_courses_by_url.get(url[url.rfind("/"):])
            if curriculum_course_info is None:
                print(f"Course {course_dto["title"]} ({util.term_id_to_name(course_dto["semesterDto"]["id"])}) belonging to URL {url} not found in curriculum!")
                equivalent_courses_by_oldest_related_course_id[int(course_dto["oldestRelatedCourseId"])] = []
                continue
            assert curriculum_course_info is not None
            path = list(curriculum_course_info["rule_node_names_by_levels"].values())
            if len(path) < 2:
                print(path)
                equivalent_courses_by_oldest_related_course_id[int(course_dto["oldestRelatedCourseId"])] = []
                continue
            if path[0] != "Elective Modules Informatics":
                equivalent_courses_by_oldest_related_course_id[int(course_dto["oldestRelatedCourseId"])] = []
                continue
            area = path[1]
            is_theory_course = "Theory" in path or "Theorie" in path
            course_id_match = course_code_regex.match(curriculum_course_info["module_name"]) if curriculum_course_info is not None else None
            course_code = course_id_match.groups()[0] if course_id_match is not None else "?"
            credits = str(curriculum_course_info["num_credits"]) if curriculum_course_info is not None else "?"
        else:
            is_theory_course = equivalent_courses[0].is_theory_course
            course_code = equivalent_courses[0].course_code
            credits = equivalent_courses[0].credits
        course = Course(
            title=course_dto["title"],
            url=url,
            course_code=course_code,
            credits=credits,
            term_id = course_dto["semesterDto"]["id"],
            term_name=util.term_id_to_name(course_dto["semesterDto"]["id"]),
            is_theory_course=is_theory_course,
            equivalent_courses=[] # will be set later
        )
        if equivalent_courses is None:
            equivalent_courses = [course]
            equivalent_courses_by_oldest_related_course_id[int(course_dto["oldestRelatedCourseId"])] = equivalent_courses
            if is_in_term_range:
                courses_by_area[area].append(course)
        else:
            equivalent_courses.append(course)

        course.equivalent_courses = equivalent_courses

    terms = [(term_id, util.term_id_to_name(term_id)) for term_id in range(args.oldtermsfrom if args.oldtermsfrom is not None else args.termid, args.termid+1) if term_id not in [201, 202]]
    terms_dict = {term_name: term_id for term_id, term_name in terms}
    terms_dict["?"] = 0 # sort "unknown" last
    include_last_offered = args.oldtermsfrom is not None
    title = f"{curriculum.heading} - offered in {terms[-1][1]}{(' and since ' + terms[0][1]) if include_last_offered else ''}"

    print(f"""\nCreating table "{title}"...""")


    curriculum_entry_paths = [list(curriculum_course_info["rule_node_names_by_levels"].values()) for curriculum_course_info in curriculum_course_infos]
    areas_according_to_curriculum_tree = list({path[1]: 0 for path in curriculum_entry_paths if len(path) >= 2 and path[0] == "Elective Modules Informatics"})
    print(areas_according_to_curriculum_tree)

    with open(args.output, "w") as file:
        file.write("<!DOCTYPE html><html lang='en'><body>")
        file.write("<div class=\"main-container\">")
        file.write(f"<h1>{title}</h1>")
        file.write(HEADER_SINGLE_TERM if args.oldtermsfrom is None else HEADER_ALL_TERMS)
        file.write(GITHUB_LINK_AND_KOFI_BUTTON)

        for area, courses_in_area in sorted(courses_by_area.items(), key=lambda area_and_val: areas_according_to_curriculum_tree.index(area_and_val[0])):
            file.write(f"<h3>{area}</h3>\n")
            file.write("<table>\n")
            file.write(
f"""<thead>
<tr style="text-align: right;">
    <th>ID</th>
    <th class="titleheader">Title</th>
    <th>Credits</th>
    <th>THEO</th>
    {'<th>Last offered</th>' if include_last_offered else ''}
</tr>
</thead>""")
            file.write("<tbody>\n")
            for course in sorted(courses_in_area, key=lambda course: (-course.term_id, course.title)):
                tags = []
                equivalent_courses = course.equivalent_courses
                if args.oldtermsfrom is None:
                    if len(equivalent_courses) == 1:
                        tags.append(dict(tag="newCourse"))
                    if (len(equivalent_courses) > 1 and equivalent_courses[0].term_id == args.termid
                            and util.term_id_distance(equivalent_courses[0].term_id, equivalent_courses[1].term_id) > 2):
                        tags.append(dict(tag="rareCourse", last_offered=util.term_id_to_name(equivalent_courses[1].term_id)))
                tags_html = " ".join(TAG_FACTORIES[tag["tag"]](tag) for tag in tags)

                file.write(
f"""<tr>
  <td>{course.course_code} {tags_html}</td>
  <td><a href="{course.url}">{course.title}</a></td>
  <td>{course.credits}</td>
  <td>{'THEO' if course.is_theory_course else ''}</td>
  {f'<td>{course.term_name}</td>' if include_last_offered else ''}
</tr>"""
            )
            file.write("</tbody></table>\n")

        file.write("</div>")
        file.write("</body>")
        file.write(STYLE)
        file.write("</html>")
    print("Wrote table to file", args.output)

if __name__ == "__main__":
    main()
